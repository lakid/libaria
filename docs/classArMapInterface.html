<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Aria: ArMapInterface Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Aria
   &#160;<span id="projectnumber">2.9.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classArMapInterface.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">ArMapInterface Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="ArMapInterface" --><!-- doxytag: inherits="ArHasFileName,ArMapInfoInterface,ArMapObjectsInterface,ArMapScanInterface,ArMapSupplementInterface" -->
<p><a class="el" href="classArMapInterface.html" title="ArMapInterface defines the methods that are available on all Aria maps.">ArMapInterface</a> defines the methods that are available on all <a class="el" href="classAria.html" title="Contains global initialization, deinitialization and other global functions.">Aria</a> maps.  
 <a href="classArMapInterface.html#details">More...</a></p>

<p><code>#include &lt;ArMapInterface.h&gt;</code></p>

<p>Inherits <a class="el" href="classArHasFileName.html">ArHasFileName</a>, <a class="el" href="classArMapInfoInterface.html">ArMapInfoInterface</a>, <a class="el" href="classArMapObjectsInterface.html">ArMapObjectsInterface</a>, <a class="el" href="classArMapScanInterface.html">ArMapScanInterface</a>, and <a class="el" href="classArMapSupplementInterface.html">ArMapSupplementInterface</a>.</p>

<p>Inherited by <a class="el" href="classArMap.html">ArMap</a>, and <a class="el" href="classArMapSimple.html">ArMapSimple</a>.</p>

<p><a href="classArMapInterface-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classArMapInterface.html#af7fa23936aff2ed8a39aa0566d1d2773a40732d41ab529094aace100632e2c16b">MAX_MAP_NAME_LENGTH</a> =  512
 }</td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a4473ac4e92936dab506739e7a20b9810">addMapChangedCB</a> (<a class="el" href="classArFunctor.html">ArFunctor</a> *functor, <a class="el" href="classArListPos.html#adb42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a> position)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a callback that is invoked when the map has been changed.  <a href="#a4473ac4e92936dab506739e7a20b9810"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a8f72e43ccdc17ca9ace947b0cd6a3647">addMapChangedCB</a> (<a class="el" href="classArFunctor.html">ArFunctor</a> *functor, int position=50)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a callback that is invoked when the map has been changed.  <a href="#a8f72e43ccdc17ca9ace947b0cd6a3647"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a40d8eea550274935ff957b93f340dc60">addPostWriteFileCB</a> (<a class="el" href="classArFunctor.html">ArFunctor</a> *functor, <a class="el" href="classArListPos.html#adb42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a> position=<a class="el" href="classArListPos.html#adb42d52c70a646c5698c5513cd25bbd0a3c55111fa6c7f63c41fc0b387f5b57d9">ArListPos::LAST</a>)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a callback to be invoked after the map file is written.  <a href="#a40d8eea550274935ff957b93f340dc60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a68292e93e05b174ee8f35ee5cd11403b">addPreMapChangedCB</a> (<a class="el" href="classArFunctor.html">ArFunctor</a> *functor, <a class="el" href="classArListPos.html#adb42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a> position)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a callback called before the map changed callbacks are called.  <a href="#a68292e93e05b174ee8f35ee5cd11403b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a7be484cdd56bc5610073ea7a70824c75">addPreMapChangedCB</a> (<a class="el" href="classArFunctor.html">ArFunctor</a> *functor, int position=50)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a callback called before the map changed callbacks are called.  <a href="#a7be484cdd56bc5610073ea7a70824c75"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a7b1e1bc876eba9f442f170449b79f69e">addPreWriteFileCB</a> (<a class="el" href="classArFunctor.html">ArFunctor</a> *functor, <a class="el" href="classArListPos.html#adb42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a> position=<a class="el" href="classArListPos.html#adb42d52c70a646c5698c5513cd25bbd0a3c55111fa6c7f63c41fc0b387f5b57d9">ArListPos::LAST</a>)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a callback to be invoked before the map file is written.  <a href="#a7b1e1bc876eba9f442f170449b79f69e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe8e08b6c419a144dc5622b785c584df"></a><!-- doxytag: member="ArMapInterface::ArMapInterface" ref="afe8e08b6c419a144dc5622b785c584df" args="()" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#afe8e08b6c419a144dc5622b785c584df">ArMapInterface</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a11d230f4851af9cd23683ec1b425f7e8">calculateChecksum</a> (unsigned char *md5DigestBuffer, size_t md5DigestBufferLen)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the checksum of the map.  <a href="#a11d230f4851af9cd23683ec1b425f7e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3545fd896f5bfa3b23c3585483d7aa8e"></a><!-- doxytag: member="ArMapInterface::clear" ref="a3545fd896f5bfa3b23c3585483d7aa8e" args="()=0" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a3545fd896f5bfa3b23c3585483d7aa8e">clear</a> ()=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the map, removing all info, objects and data points and lines. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classArMapInterface.html">ArMapInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#abc68f5bb2b270a3621206c0bb60de750">clone</a> ()=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new map that is "equivalent" to this map.  <a href="#abc68f5bb2b270a3621206c0bb60de750"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c7ea2928593dabdb79eaf328f803123"></a><!-- doxytag: member="ArMapInterface::createRealFileName" ref="a1c7ea2928593dabdb79eaf328f803123" args="(const char *fileName)=0" -->
virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a1c7ea2928593dabdb79eaf328f803123">createRealFileName</a> (const char *fileName)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepends the appropriate directory information on the given filename. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classArArgumentBuilder.html">ArArgumentBuilder</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a69999157a3713d4ada7d47f6a3087b73">findMapObjectParams</a> (const char *mapObjectName)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the optional parameters associated with a map object, or NULL if none.  <a href="#a69999157a3713d4ada7d47f6a3087b73"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a75aadc1642ea9f8f6004c09fa94306"></a><!-- doxytag: member="ArMapInterface::getBaseDirectory" ref="a6a75aadc1642ea9f8f6004c09fa94306" args="(void) const =0" -->
virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a6a75aadc1642ea9f8f6004c09fa94306">getBaseDirectory</a> (void) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the base directory. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a209d91e860f6c22478b6b91a190a59a0"></a><!-- doxytag: member="ArMapInterface::getChildObjects" ref="a209d91e860f6c22478b6b91a190a59a0" args="()=0" -->
virtual <a class="el" href="classArMapObjectsInterface.html">ArMapObjectsInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a209d91e860f6c22478b6b91a190a59a0">getChildObjects</a> ()=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides direct access to the child map objects which are used to define group templates. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e4b9de7ebaa896d12728e2b16d5eb0f"></a><!-- doxytag: member="ArMapInterface::getFileName" ref="a4e4b9de7ebaa896d12728e2b16d5eb0f" args="(void) const =0" -->
virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a4e4b9de7ebaa896d12728e2b16d5eb0f">getFileName</a> (void) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the fileName that was loaded. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#abd35c2a4363d41c6633fd064a45188bd">getIgnoreCase</a> (void)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether we ignore case or not.  <a href="#abd35c2a4363d41c6633fd064a45188bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#ae71fec67708492f07fe4cf88fe5bd570">getIgnoreEmptyFileName</a> (void)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether we ignore empty file names or fail if we encounter one.  <a href="#ae71fec67708492f07fe4cf88fe5bd570"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classArMapInfoInterface.html">ArMapInfoInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#af71351c58a7c772b852002babf282220">getInactiveInfo</a> ()=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides direct access to the inactive map info.  <a href="#af71351c58a7c772b852002babf282220"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classArMapObjectsInterface.html">ArMapObjectsInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a06520aefeb5654a4b4adae7f4b5c0e5a">getInactiveObjects</a> ()=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides direct access to the inactive map objects.  <a href="#a06520aefeb5654a4b4adae7f4b5c0e5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55d2dc775f7dfb095f4a97c1c8493f82"></a><!-- doxytag: member="ArMapInterface::getMapChangedLogLevel" ref="a55d2dc775f7dfb095f4a97c1c8493f82" args="(void)=0" -->
virtual <a class="el" href="classArLog.html#ac8cc0fb3aa323ab2a1c21340fdd1dce3">ArLog::LogLevel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a55d2dc775f7dfb095f4a97c1c8493f82">getMapChangedLogLevel</a> (void)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the level at which information about the map changed callbacks is logged. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a42438b0cdb01d4f1613b05dcaa8bae60">getMapId</a> (<a class="el" href="classArMapId.html">ArMapId</a> *mapIdOut, bool isInternalCall=false)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the map ID.  <a href="#a42438b0cdb01d4f1613b05dcaa8bae60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual struct stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#ab9736c0a90ec57e51b3415ef787de861">getReadFileStat</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns information about the map file that was read.  <a href="#ab9736c0a90ec57e51b3415ef787de861"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::list<br class="typebreak"/>
&lt; <a class="el" href="classArArgumentBuilder.html">ArArgumentBuilder</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a33d5f7c640ead8c14268379b35d5cbe0">getRemainder</a> ()=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of the map file lines that were not recognized.  <a href="#a33d5f7c640ead8c14268379b35d5cbe0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::list&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#af1c75dac69881ba57ffd7826dd600a32">getScanTypes</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of the scan types that are defined for this map.  <a href="#af1c75dac69881ba57ffd7826dd600a32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15ff7bcde5b7655300e8e35f59eaab7a"></a><!-- doxytag: member="ArMapInterface::getTempDirectory" ref="a15ff7bcde5b7655300e8e35f59eaab7a" args="(void) const =0" -->
virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a15ff7bcde5b7655300e8e35f59eaab7a">getTempDirectory</a> (void) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the temp directory. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a660969c77405c2795a47ce58f0625977">isLoadingDataStarted</a> ()=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This value returns true once the first DATA tag has been reached.  <a href="#a660969c77405c2795a47ce58f0625977"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a6d2628ce711c2d6774746586932f7913">isLoadingLinesAndDataStarted</a> ()=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This value returns true once the first LINES tag has been reached.  <a href="#a6d2628ce711c2d6774746586932f7913"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e72e85ff0680d98570b096cf24938ba"></a><!-- doxytag: member="ArMapInterface::lock" ref="a2e72e85ff0680d98570b096cf24938ba" args="()=0" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a2e72e85ff0680d98570b096cf24938ba">lock</a> ()=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the map instance. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a00f12f15367b9c97592b0f45fda2fc2f">mapChanged</a> (void)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that will call the map changed CBs if needed.  <a href="#a00f12f15367b9c97592b0f45fda2fc2f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a7a5270bda8f803df83079940ac6e15e5">parseLine</a> (char *line)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Public for ArQMapProducer.  <a href="#a7a5270bda8f803df83079940ac6e15e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7aa64d691b47caab38efa72a90767294"></a><!-- doxytag: member="ArMapInterface::parsingComplete" ref="a7aa64d691b47caab38efa72a90767294" args="(void)=0" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a7aa64d691b47caab38efa72a90767294">parsingComplete</a> (void)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Says that the parsing by lines is done and to use the parsed data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a9ec33c9ef77c8d6fcd6f68b33d0385d9">readFile</a> (const char *fileName, char *errorBuffer=NULL, size_t errorBufferLen=0, unsigned char *md5DigestBuffer=NULL, size_t md5DigestBufferLen=0)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the map from the specified file.  <a href="#a9ec33c9ef77c8d6fcd6f68b33d0385d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a412f9906797ed2e34e6d4589033e3d80">refresh</a> ()=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the map file needs to be re-read.  <a href="#a412f9906797ed2e34e6d4589033e3d80"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a65da492e1379f9a9d226b552a2be65d3">remMapChangedCB</a> (<a class="el" href="classArFunctor.html">ArFunctor</a> *functor)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a callback called when the map has been changed.  <a href="#a65da492e1379f9a9d226b552a2be65d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a80f3ea46ca3969d4eaf6253b39c84f5c">remPostWriteFileCB</a> (<a class="el" href="classArFunctor.html">ArFunctor</a> *functor)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the given callback from the list of post-write callbacks.  <a href="#a80f3ea46ca3969d4eaf6253b39c84f5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a0563d1953c0795a0ee85ebb2a7c9b13c">remPreMapChangedCB</a> (<a class="el" href="classArFunctor.html">ArFunctor</a> *functor)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the specified "pre-map-changed callback".  <a href="#a0563d1953c0795a0ee85ebb2a7c9b13c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a44fbadba38009509c473ca622a59b8b1">remPreWriteFileCB</a> (<a class="el" href="classArFunctor.html">ArFunctor</a> *functor)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the given callback from the list of pre-write callbacks.  <a href="#a44fbadba38009509c473ca622a59b8b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a20061ab5be4b9b469a7221ca12fdd9be">set</a> (<a class="el" href="classArMapInterface.html">ArMapInterface</a> *other)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this map to be "equivalent" to the given other map.  <a href="#a20061ab5be4b9b469a7221ca12fdd9be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2389288fc4c29e1d380cd961877c2acd"></a><!-- doxytag: member="ArMapInterface::setBaseDirectory" ref="a2389288fc4c29e1d380cd961877c2acd" args="(const char *baseDirectory)=0" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a2389288fc4c29e1d380cd961877c2acd">setBaseDirectory</a> (const char *baseDirectory)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the base directory. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a60ca7573c074769719b00c3c96ec17c4">setIgnoreCase</a> (bool ignoreCase=false)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether we ignore case or not.  <a href="#a60ca7573c074769719b00c3c96ec17c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#aa65367c7823f46fdae42d53f201699a5">setIgnoreEmptyFileName</a> (bool ignore)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether we ignore empty file names or fail if we encounter one.  <a href="#aa65367c7823f46fdae42d53f201699a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5774ac76e0e7dc6b47a5125bc00c2b51"></a><!-- doxytag: member="ArMapInterface::setMapChangedLogLevel" ref="a5774ac76e0e7dc6b47a5125bc00c2b51" args="(ArLog::LogLevel level)=0" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a5774ac76e0e7dc6b47a5125bc00c2b51">setMapChangedLogLevel</a> (<a class="el" href="classArLog.html#ac8cc0fb3aa323ab2a1c21340fdd1dce3">ArLog::LogLevel</a> level)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the level at which to log information about the map changed callbacks. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#acac90c5ce18a25ecd6d08ce8116a27aa">setMapObjectParams</a> (const char *mapObjectName, <a class="el" href="classArArgumentBuilder.html">ArArgumentBuilder</a> *params, <a class="el" href="classArMapChangeDetails.html">ArMapChangeDetails</a> *changeDetails=NULL)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the optional parameters associated with a map object.  <a href="#acac90c5ce18a25ecd6d08ce8116a27aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3226d90f6e888de43fa4ab4e86c1a52"></a><!-- doxytag: member="ArMapInterface::setQuiet" ref="ac3226d90f6e888de43fa4ab4e86c1a52" args="(bool isQuiet)=0" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#ac3226d90f6e888de43fa4ab4e86c1a52">setQuiet</a> (bool isQuiet)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on this flag to reduce the number of verbose log messages. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#ac519568cc0d2e3a87d4e7feabf04a7aa">setScanTypes</a> (const std::list&lt; std::string &gt; &amp;scanTypeList)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the scan types that are defined for this map.  <a href="#ac519568cc0d2e3a87d4e7feabf04a7aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#adc9644192ab38bd3b8a019d6e910ef42">setSourceFileName</a> (const char *sourceName, const char *fileName, bool isInternalCall=false)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the name of the source and the file from which the map was loaded.  <a href="#adc9644192ab38bd3b8a019d6e910ef42"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3dbb287b9996bc395755015c6474b01c"></a><!-- doxytag: member="ArMapInterface::setTempDirectory" ref="a3dbb287b9996bc395755015c6474b01c" args="(const char *tempDirectory)=0" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a3dbb287b9996bc395755015c6474b01c">setTempDirectory</a> (const char *tempDirectory)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the temp directory. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43cd5a39e989e99453e59fad86408897"></a><!-- doxytag: member="ArMapInterface::tryLock" ref="a43cd5a39e989e99453e59fad86408897" args="()=0" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a43cd5a39e989e99453e59fad86408897">tryLock</a> ()=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to lock the map instance without blocking. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f53472e8700abcc05a85b9f7a7d6820"></a><!-- doxytag: member="ArMapInterface::unlock" ref="a0f53472e8700abcc05a85b9f7a7d6820" args="()=0" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a0f53472e8700abcc05a85b9f7a7d6820">unlock</a> ()=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the map instance. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#ade2aaba8c0a991964c2a623987a589fe">writeFile</a> (const char *fileName, bool internalCall=false, unsigned char *md5DigestBuffer=NULL, size_t md5DigestBufferLen=0, time_t fileTimestamp=-1)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the map to the specified file.  <a href="#ade2aaba8c0a991964c2a623987a589fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#abc4e372308bbf06195dea3c0bccc93b8">writeObjectsToFunctor</a> (<a class="el" href="classArFunctor1.html">ArFunctor1</a>&lt; const char * &gt; *functor, const char *endOfLineChars, bool isOverrideAsSingleScan=false, const char *maxCategory=NULL)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the map header information and objects to a text-based functor.  <a href="#abc4e372308bbf06195dea3c0bccc93b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a4721211e839289dc8ab24202e07471cc">writeToFunctor</a> (<a class="el" href="classArFunctor1.html">ArFunctor1</a>&lt; const char * &gt; *functor, const char *endOfLineChars)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes all of the map to the given text-based functor.  <a href="#a4721211e839289dc8ab24202e07471cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3a168bc2130af13b415979a75e536fa"></a><!-- doxytag: member="ArMapInterface::~ArMapInterface" ref="ab3a168bc2130af13b415979a75e536fa" args="(void)" -->
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#ab3a168bc2130af13b415979a75e536fa">~ArMapInterface</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#aadffe2b39f07bbc856355e1b70a08be0">createRealFileName</a> (const char *baseDirectory, const char *fileName, bool isIgnoreCase)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method creates a full file path name from the given components.  <a href="#aadffe2b39f07bbc856355e1b70a08be0"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a534fc541999ac13d2afb7297458e0a28"></a><!-- doxytag: member="ArMapInterface::MAP_CATEGORY_2D" ref="a534fc541999ac13d2afb7297458e0a28" args="" -->
static const char *&#160;</td><td class="memItemRight" valign="bottom"><b>MAP_CATEGORY_2D</b> = &quot;2D-Map&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e0c7cffd95768e5eecb468ca1c116bc"></a><!-- doxytag: member="ArMapInterface::MAP_CATEGORY_2D_COMPOSITE" ref="a8e0c7cffd95768e5eecb468ca1c116bc" args="" -->
static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a8e0c7cffd95768e5eecb468ca1c116bc">MAP_CATEGORY_2D_COMPOSITE</a> = &quot;2D-Map-Ex3&quot;</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Superset of extended; includes group objects and parent maps. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ecb554bd7784500b4495dbc8a64fb71"></a><!-- doxytag: member="ArMapInterface::MAP_CATEGORY_2D_EXTENDED" ref="a0ecb554bd7784500b4495dbc8a64fb71" args="" -->
static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArMapInterface.html#a0ecb554bd7784500b4495dbc8a64fb71">MAP_CATEGORY_2D_EXTENDED</a> = &quot;2D-Map-Ex2&quot;</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Superset of multi-sources; includes advanced Info types, CairnInfo and CustomInfo. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad893149ccf58439c104cae7b77e01fc6"></a><!-- doxytag: member="ArMapInterface::MAP_CATEGORY_2D_MULTI_SOURCES" ref="ad893149ccf58439c104cae7b77e01fc6" args="" -->
static const char *&#160;</td><td class="memItemRight" valign="bottom"><b>MAP_CATEGORY_2D_MULTI_SOURCES</b> = &quot;2D-Map-Ex&quot;</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classArMapInterface.html" title="ArMapInterface defines the methods that are available on all Aria maps.">ArMapInterface</a> defines the methods that are available on all <a class="el" href="classAria.html" title="Contains global initialization, deinitialization and other global functions.">Aria</a> maps. </p>
<p>These maps represent the operating space of a robot, and can be used for space searching, localizing, navigating etc. The types of data stored in a map include sensable obstacles (e.g. walls and furniture in a room) represented either as a collection of data points (similar to a raster or bit map, useful for high resolution sensors like a laser), or lines (a vector map, useful for low resolution sensors like the sonar), goals, and other points or regions of interest ("map objects").</p>
<p>The methods in <a class="el" href="classArMapInterface.html" title="ArMapInterface defines the methods that are available on all Aria maps.">ArMapInterface</a> can be broadly categorized as follows:</p>
<ul>
<li>Scan Methods: These provide access the sensable obstacles that are represented as a collection of data points or lines. These are typically generated during the scanning process (i.e. the creation of the .2d file). If more than one sensor is used, then the data is organized on a per-sensor basis. The scan methods are grouped into the <a class="el" href="classArMapScanInterface.html" title="Methods related to setting and retrieving the scan-related data in an Aria map.">ArMapScanInterface</a>.</li>
<li>Object Methods: These provide access to the "high-level" objects in the environment. Such objects include goals, docks, forbidden areas, and other user-defined points of interest. They may also include special data objects that are actually part of the operating environment and are generally added automatically and are not editable by the user. The object methods are grouped into the <a class="el" href="classArMapObjectsInterface.html" title="Methods related to setting and retrieving the objects in an Aria map.">ArMapObjectsInterface</a>.</li>
<li>Info Methods: A wide variety of supporting information is included in various "info" categories. This includes definitions for the types of map objects that can be stored in the map. It also includes various optional features such as macros and schedules. The info methods are grouped into the <a class="el" href="classArMapInfoInterface.html" title="Methods related to setting and retrieving the various &quot;info&quot; tags in an Aria map.">ArMapInfoInterface</a>.</li>
<li>Extra Data Methods: These are essentially the "leftovers" -- i.e. methods that are related directly to map data but which do not fit into any of the above categories. They are defined in the <a class="el" href="classArMapSupplementInterface.html" title="Methods related to miscellaneous extra data in an Aria map.">ArMapSupplementInterface</a>.</li>
<li>Callback Methods: Users of the <a class="el" href="classAria.html" title="Contains global initialization, deinitialization and other global functions.">Aria</a> map may install callbacks onto the map in order to be notified when the map contents has changed. These methods are defined below.</li>
<li>File and I/O Methods: Methods to read and write map files are also included below. In addition, the MD5 checksum of the map contents may be calculated.</li>
</ul>
<p>TODO:</p>
<ul>
<li>Possibly make the calculation of checksums optional? </li>
</ul>
</div><hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="af7fa23936aff2ed8a39aa0566d1d2773"></a><!-- doxytag: member="ArMapInterface::@14" ref="af7fa23936aff2ed8a39aa0566d1d2773" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="af7fa23936aff2ed8a39aa0566d1d2773a40732d41ab529094aace100632e2c16b"></a><!-- doxytag: member="MAX_MAP_NAME_LENGTH" ref="af7fa23936aff2ed8a39aa0566d1d2773a40732d41ab529094aace100632e2c16b" args="" -->MAX_MAP_NAME_LENGTH</em>&nbsp;</td><td>
<p>Maximum length of the map file's name. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a4473ac4e92936dab506739e7a20b9810"></a><!-- doxytag: member="ArMapInterface::addMapChangedCB" ref="a4473ac4e92936dab506739e7a20b9810" args="(ArFunctor *functor, ArListPos::Pos position)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classArMapInterface.html#a4473ac4e92936dab506739e7a20b9810">ArMapInterface::addMapChangedCB</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor.html">ArFunctor</a> *&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArListPos.html#adb42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a>&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a callback that is invoked when the map has been changed. </p>
<p>The given functor should assume that the map has been <a class="el" href="classArMapInterface.html#a2e72e85ff0680d98570b096cf24938ba" title="Lock the map instance.">lock()</a>-ed when it is invoked. It should also not attempt to make changes to the <a class="el" href="classArMapInterface.html#a00f12f15367b9c97592b0f45fda2fc2f" title="Function that will call the map changed CBs if needed.">mapChanged()</a> callback list during the invoke method. This method is not thread-safe.</p>
<p>This method is just a wrapper for compatibility, the one that takes position as an integer is the main one that should be used now.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>a pointer to the <a class="el" href="classArFunctor.html" title="An object which allows storing a generalized reference to a method with an object instance to call la...">ArFunctor</a> to be invoked; must be non-NULL </td></tr>
    <tr><td class="paramname">position</td><td>the <a class="el" href="classArListPos.html#adb42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a> indication at which to add the functor (i.e. at the beginning or at the end of the callback list) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8f72e43ccdc17ca9ace947b0cd6a3647"></a><!-- doxytag: member="ArMapInterface::addMapChangedCB" ref="a8f72e43ccdc17ca9ace947b0cd6a3647" args="(ArFunctor *functor, int position=50)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classArMapInterface.html#a4473ac4e92936dab506739e7a20b9810">ArMapInterface::addMapChangedCB</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor.html">ArFunctor</a> *&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>position</em> = <code>50</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a callback that is invoked when the map has been changed. </p>
<p>The given functor should assume that the map has been <a class="el" href="classArMapInterface.html#a2e72e85ff0680d98570b096cf24938ba" title="Lock the map instance.">lock()</a>-ed when it is invoked. It should also not attempt to make changes to the <a class="el" href="classArMapInterface.html#a00f12f15367b9c97592b0f45fda2fc2f" title="Function that will call the map changed CBs if needed.">mapChanged()</a> callback list during the invoke method. This method is not thread-safe.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>a pointer to the <a class="el" href="classArFunctor.html" title="An object which allows storing a generalized reference to a method with an object instance to call la...">ArFunctor</a> to be invoked; must be non-NULL</td></tr>
    <tr><td class="paramname">position</td><td>this indicates the order in which the functors will be called, the nominal range is 0 to 100, highest is called first </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a40d8eea550274935ff957b93f340dc60"></a><!-- doxytag: member="ArMapInterface::addPostWriteFileCB" ref="a40d8eea550274935ff957b93f340dc60" args="(ArFunctor *functor, ArListPos::Pos position=ArListPos::LAST)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classArMapInterface.html#a40d8eea550274935ff957b93f340dc60">ArMapInterface::addPostWriteFileCB</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor.html">ArFunctor</a> *&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArListPos.html#adb42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a>&#160;</td>
          <td class="paramname"><em>position</em> = <code><a class="el" href="classArListPos.html#adb42d52c70a646c5698c5513cd25bbd0a3c55111fa6c7f63c41fc0b387f5b57d9">ArListPos::LAST</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a callback to be invoked after the map file is written. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>the <a class="el" href="classArFunctor.html" title="An object which allows storing a generalized reference to a method with an object instance to call la...">ArFunctor</a> * callback to be added </td></tr>
    <tr><td class="paramname">position</td><td>the <a class="el" href="classArListPos.html#adb42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a> that specifies whether the callback should be added at the front or the back of the list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a68292e93e05b174ee8f35ee5cd11403b"></a><!-- doxytag: member="ArMapInterface::addPreMapChangedCB" ref="a68292e93e05b174ee8f35ee5cd11403b" args="(ArFunctor *functor, ArListPos::Pos position)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classArMapInterface.html#a68292e93e05b174ee8f35ee5cd11403b">ArMapInterface::addPreMapChangedCB</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor.html">ArFunctor</a> *&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArListPos.html#adb42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a>&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a callback called before the map changed callbacks are called. </p>
<p>The "pre-map-changed callbacks" are invoked *after* the map has been changed, but before the other "map-changed callbacks" are invoked. This method is not thread-safe.</p>
<p>This method is just a wrapper for compatibility, the one that takes position as an integer is the main one that should be used now.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>a pointer to the <a class="el" href="classArFunctor.html" title="An object which allows storing a generalized reference to a method with an object instance to call la...">ArFunctor</a> to be invoked; must be non-NULL </td></tr>
    <tr><td class="paramname">position</td><td>the <a class="el" href="classArListPos.html#adb42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a> indication at which to add the functor (i.e. at the beginning or at the end of the callback list)</td></tr>
  </table>
  </dd>
</dl>
<p><b>Java and Python Wrappers:</b> call as addPreMapChangedCBPos() if passing an <a class="el" href="classArListPos.html#adb42d52c70a646c5698c5513cd25bbd0">ArListPos.Pos</a> object for <em>position</em> rather than an int </p>

</div>
</div>
<a class="anchor" id="a7be484cdd56bc5610073ea7a70824c75"></a><!-- doxytag: member="ArMapInterface::addPreMapChangedCB" ref="a7be484cdd56bc5610073ea7a70824c75" args="(ArFunctor *functor, int position=50)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classArMapInterface.html#a68292e93e05b174ee8f35ee5cd11403b">ArMapInterface::addPreMapChangedCB</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor.html">ArFunctor</a> *&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>position</em> = <code>50</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a callback called before the map changed callbacks are called. </p>
<p>The "pre-map-changed callbacks" are invoked *after* the map has been changed, but before the other "map-changed callbacks" are invoked. This method is not thread-safe.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>a pointer to the <a class="el" href="classArFunctor.html" title="An object which allows storing a generalized reference to a method with an object instance to call la...">ArFunctor</a> to be invoked; must be non-NULL</td></tr>
    <tr><td class="paramname">position</td><td>this indicates the order in which the functors will be called, the nominal range is 0 to 100, highest is called first </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7b1e1bc876eba9f442f170449b79f69e"></a><!-- doxytag: member="ArMapInterface::addPreWriteFileCB" ref="a7b1e1bc876eba9f442f170449b79f69e" args="(ArFunctor *functor, ArListPos::Pos position=ArListPos::LAST)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classArMapInterface.html#a7b1e1bc876eba9f442f170449b79f69e">ArMapInterface::addPreWriteFileCB</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor.html">ArFunctor</a> *&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArListPos.html#adb42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a>&#160;</td>
          <td class="paramname"><em>position</em> = <code><a class="el" href="classArListPos.html#adb42d52c70a646c5698c5513cd25bbd0a3c55111fa6c7f63c41fc0b387f5b57d9">ArListPos::LAST</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a callback to be invoked before the map file is written. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>the <a class="el" href="classArFunctor.html" title="An object which allows storing a generalized reference to a method with an object instance to call la...">ArFunctor</a> * callback to be added </td></tr>
    <tr><td class="paramname">position</td><td>the <a class="el" href="classArListPos.html#adb42d52c70a646c5698c5513cd25bbd0">ArListPos::Pos</a> that specifies whether the callback should be added at the front or the back of the list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a11d230f4851af9cd23683ec1b425f7e8"></a><!-- doxytag: member="ArMapInterface::calculateChecksum" ref="a11d230f4851af9cd23683ec1b425f7e8" args="(unsigned char *md5DigestBuffer, size_t md5DigestBufferLen)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classArMapInterface.html#a11d230f4851af9cd23683ec1b425f7e8">ArMapInterface::calculateChecksum</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>md5DigestBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>md5DigestBufferLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the checksum of the map. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">md5DigestBuffer</td><td>the unsigned char buffer in which to store the calculated checksum </td></tr>
    <tr><td class="paramname">md5DigestBufferLen</td><td>the length of the md5DigestBuffer; should be <a class="el" href="classArMD5Calculator.html#a16841a56222cfaf5723162c1d86a8b3ba1c49adf9388dec84457b4f47ec6a0cbb" title="Number of bytes in the checksum buffer.">ArMD5Calculator::DIGEST_LENGTH</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bool true if the checksum was successfully calculated; false if an error occurrred </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classArMD5Calculator.html" title="Calculates the MD5 checksum when reading or writing a text file using ArFunctors.">ArMD5Calculator</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abc68f5bb2b270a3621206c0bb60de750"></a><!-- doxytag: member="ArMapInterface::clone" ref="abc68f5bb2b270a3621206c0bb60de750" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classArMapInterface.html">ArMapInterface</a>* <a class="el" href="classArMapInterface.html#abc68f5bb2b270a3621206c0bb60de750">ArMapInterface::clone</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new map that is "equivalent" to this map. </p>
<p>Creates a new map that is effectively a copy of this map. Note, however, that the returned map may not be of exactly the same class (so the term "clone" is being used somewhat loosely). In particular, if the active <a class="el" href="classArMap.html" title="A map of a two-dimensional space the robot can navigate within, and which can be updated via the Aria...">ArMap</a> that is associated with the robot configuration is cloned, then the resulting map will be simpler and not associated with the robot configuration. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classArMapInterface.html" title="ArMapInterface defines the methods that are available on all Aria maps.">ArMapInterface</a> * a new copy of this map </dd></dl>
<p><b>Java Wrapper Library:</b> Use cloneMap() instead </p>

</div>
</div>
<a class="anchor" id="aadffe2b39f07bbc856355e1b70a08be0"></a><!-- doxytag: member="ArMapInterface::createRealFileName" ref="aadffe2b39f07bbc856355e1b70a08be0" args="(const char *baseDirectory, const char *fileName, bool isIgnoreCase)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classArMapInterface.html#aadffe2b39f07bbc856355e1b70a08be0">ArMapInterface::createRealFileName</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>baseDirectory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isIgnoreCase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper method creates a full file path name from the given components. </p>
<p>Determines what system file path to use based on the contents of <em>baseDirectory</em>, <em>fileName</em> and <em>isIgnoreCase</em>.</p>
<p>If <em>fileName</em> is not an absolute path and <em>baseDirectory</em> is not null and not empty, then it is combined with <em>baseDirectory</em> to form a full path. An absolute path starts with the '/' or '\' character, or on Windows, with "X:\" where X is any upper or lower case alphabetic character A-Z or a-z. </p>

</div>
</div>
<a class="anchor" id="a69999157a3713d4ada7d47f6a3087b73"></a><!-- doxytag: member="ArMapInterface::findMapObjectParams" ref="a69999157a3713d4ada7d47f6a3087b73" args="(const char *mapObjectName)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classArArgumentBuilder.html">ArArgumentBuilder</a>* <a class="el" href="classArMapInterface.html#a69999157a3713d4ada7d47f6a3087b73">ArMapInterface::findMapObjectParams</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mapObjectName</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the optional parameters associated with a map object, or NULL if none. </p>
<p>The <a class="el" href="classAria.html" title="Contains global initialization, deinitialization and other global functions.">Aria</a> map provides an advanced feature that allows a parameter list to be defined for custom map object types. (Refer to the <a class="el" href="classArMap.html" title="A map of a two-dimensional space the robot can navigate within, and which can be updated via the Aria...">ArMap</a> MapFileFormat for more information.)</p>
<p>This convenience method provides access to the parameter values for a specified map object. It is basically a shortcut for searching and parsing the CairnInfo argument list. Unlike the CairnInfo arguments (which also include an introduction and map object name), the argument builder returned by this method only contains the parameter values. Also note that if the argument builder contains string parameters, then they may be surrounded by quotes.</p>
<p>The returned pointer should not be stored, modified, or deleted.</p>
<p>See setMapObjectParams for important information about changing the parameter values or the associated map object.</p>
<p>This method is not thread-safe. (The call and use of the returned <a class="el" href="classArArgumentBuilder.html" title="This class is to build arguments for things that require argc and argv.">ArArgumentBuilder</a> should be surrounded by calls to <a class="el" href="classArMapInterface.html#a2e72e85ff0680d98570b096cf24938ba" title="Lock the map instance.">lock()</a>/unlock().)</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mapObjectName</td><td>the unique char * name of the map object whose parameters are to be retrieved </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classArArgumentBuilder.html" title="This class is to build arguments for things that require argc and argv.">ArArgumentBuilder</a> * a pointer to the map object's parameter values; </dd></dl>

</div>
</div>
<a class="anchor" id="abd35c2a4363d41c6633fd064a45188bd"></a><!-- doxytag: member="ArMapInterface::getIgnoreCase" ref="abd35c2a4363d41c6633fd064a45188bd" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classArMapInterface.html#abd35c2a4363d41c6633fd064a45188bd">ArMapInterface::getIgnoreCase</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets whether we ignore case or not. </p>
<p>This method is primarily applicable to the active <a class="el" href="classAria.html" title="Contains global initialization, deinitialization and other global functions.">Aria</a> map that is associated with the robot configuration. </p>

</div>
</div>
<a class="anchor" id="ae71fec67708492f07fe4cf88fe5bd570"></a><!-- doxytag: member="ArMapInterface::getIgnoreEmptyFileName" ref="ae71fec67708492f07fe4cf88fe5bd570" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classArMapInterface.html#ae71fec67708492f07fe4cf88fe5bd570">ArMapInterface::getIgnoreEmptyFileName</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets whether we ignore empty file names or fail if we encounter one. </p>
<p>This method is primarily applicable to the active <a class="el" href="classAria.html" title="Contains global initialization, deinitialization and other global functions.">Aria</a> map that is associated with the robot configuration. </p>

</div>
</div>
<a class="anchor" id="af71351c58a7c772b852002babf282220"></a><!-- doxytag: member="ArMapInterface::getInactiveInfo" ref="af71351c58a7c772b852002babf282220" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classArMapInfoInterface.html">ArMapInfoInterface</a>* <a class="el" href="classArMapInterface.html#af71351c58a7c772b852002babf282220">ArMapInterface::getInactiveInfo</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides direct access to the inactive map info. </p>
<p>The "inactive" info is a section of the <a class="el" href="classAria.html" title="Contains global initialization, deinitialization and other global functions.">Aria</a> map that applications may use to store "_XInfo:" lines that are not currently active or applicable. The inactive info will be written to the map file, but it will not be included in any of the inherited <a class="el" href="classArMapInfoInterface.html" title="Methods related to setting and retrieving the various &quot;info&quot; tags in an Aria map.">ArMapInfoInterface</a> calls (e.g. getInfo(type)). This is primarily intended for advanced specialized use where something needs to be removed from the map file, but it may be necessary to restore it later. This method is not thread-safe. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classArMapInfoInterface.html" title="Methods related to setting and retrieving the various &quot;info&quot; tags in an Aria map.">ArMapInfoInterface</a> * a pointer to the inactive map info section </dd></dl>

</div>
</div>
<a class="anchor" id="a06520aefeb5654a4b4adae7f4b5c0e5a"></a><!-- doxytag: member="ArMapInterface::getInactiveObjects" ref="a06520aefeb5654a4b4adae7f4b5c0e5a" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classArMapObjectsInterface.html">ArMapObjectsInterface</a>* <a class="el" href="classArMapInterface.html#a06520aefeb5654a4b4adae7f4b5c0e5a">ArMapInterface::getInactiveObjects</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides direct access to the inactive map objects. </p>
<p>The "inactive" objects is a section of the <a class="el" href="classAria.html" title="Contains global initialization, deinitialization and other global functions.">Aria</a> map that applications may use to store "_Cairn" lines that are not currently active or applicable. The inactive objects will be written to the map file, but they will not be included in any of the inherited <a class="el" href="classArMapObjectsInterface.html" title="Methods related to setting and retrieving the objects in an Aria map.">ArMapObjectsInterface</a> calls (e.g. <a class="el" href="classArMapObjectsInterface.html#a66394898f80b1917b5f96aa4b7a8e37c" title="Returns a pointer to the internal list of map objects.">getMapObjects()</a>). This is primarily intended for advanced specialized use where an object needs to be removed from the map file, but it may be necessary to restore it later. This method is not thread-safe. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classArMapObjectsInterface.html" title="Methods related to setting and retrieving the objects in an Aria map.">ArMapObjectsInterface</a> * a pointer to the inactive map objects section </dd></dl>

</div>
</div>
<a class="anchor" id="a42438b0cdb01d4f1613b05dcaa8bae60"></a><!-- doxytag: member="ArMapInterface::getMapId" ref="a42438b0cdb01d4f1613b05dcaa8bae60" args="(ArMapId *mapIdOut, bool isInternalCall=false)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classArMapInterface.html#a42438b0cdb01d4f1613b05dcaa8bae60">ArMapInterface::getMapId</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArMapId.html">ArMapId</a> *&#160;</td>
          <td class="paramname"><em>mapIdOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isInternalCall</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the map ID. </p>
<p>The map ID is a unique identifier based on the map file name and the checksum data. (Perhaps more accurately, it is highly likely to be unique during normal usage.) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mapIdOut</td><td>a pointer to the <a class="el" href="classArMapId.html" title="Enapsulates the data used to uniquely identify an Aria map.">ArMapId</a> to be set </td></tr>
    <tr><td class="paramname">isInternalCall</td><td>a bool set to true only when getMapId is called within the context of a method that has already locked the map; if false, then the map is locked by this method </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bool true if the map ID was successfully set; false, otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ab9736c0a90ec57e51b3415ef787de861"></a><!-- doxytag: member="ArMapInterface::getReadFileStat" ref="ab9736c0a90ec57e51b3415ef787de861" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual struct stat <a class="el" href="classArMapInterface.html#ab9736c0a90ec57e51b3415ef787de861">ArMapInterface::getReadFileStat</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [read, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns information about the map file that was read. </p>

<p>Implemented in <a class="el" href="classArMapSimple.html#aa4905db6761bbdad452da8e08f1ca871">ArMapSimple</a>, and <a class="el" href="classArMap.html#a0413938cf922ff7f52e31b42fbbabfee">ArMap</a>.</p>

</div>
</div>
<a class="anchor" id="a33d5f7c640ead8c14268379b35d5cbe0"></a><!-- doxytag: member="ArMapInterface::getRemainder" ref="a33d5f7c640ead8c14268379b35d5cbe0" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::list&lt;<a class="el" href="classArArgumentBuilder.html">ArArgumentBuilder</a> *&gt;* <a class="el" href="classArMapInterface.html#a33d5f7c640ead8c14268379b35d5cbe0">ArMapInterface::getRemainder</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a list of the map file lines that were not recognized. </p>
<p>Ideally, the returned list should be empty. The remainder list is primarily used to determine whether the editor is up-to-date for the current map version and to try to minimize lost data.</p>
<p>Note that this method returns a pointer to the actual list that is stored in the map object. It is not safe to store this pointer.</p>
<p>This method is not thread-safe. </p>

</div>
</div>
<a class="anchor" id="af1c75dac69881ba57ffd7826dd600a32"></a><!-- doxytag: member="ArMapInterface::getScanTypes" ref="af1c75dac69881ba57ffd7826dd600a32" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::list&lt;std::string&gt; <a class="el" href="classArMapInterface.html#af1c75dac69881ba57ffd7826dd600a32">ArMapInterface::getScanTypes</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a list of the scan types that are defined for this map. </p>
<p>This method is not thread-safe.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>std::list&lt;std::string&gt; a list of the scan types that are defined for this map </dd></dl>

</div>
</div>
<a class="anchor" id="a660969c77405c2795a47ce58f0625977"></a><!-- doxytag: member="ArMapInterface::isLoadingDataStarted" ref="a660969c77405c2795a47ce58f0625977" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classArMapInterface.html#a660969c77405c2795a47ce58f0625977">ArMapInterface::isLoadingDataStarted</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This value returns true once the first DATA tag has been reached. </p>
<p>The rest of the map contains data points. </p>

</div>
</div>
<a class="anchor" id="a6d2628ce711c2d6774746586932f7913"></a><!-- doxytag: member="ArMapInterface::isLoadingLinesAndDataStarted" ref="a6d2628ce711c2d6774746586932f7913" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classArMapInterface.html#a6d2628ce711c2d6774746586932f7913">ArMapInterface::isLoadingLinesAndDataStarted</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This value returns true once the first LINES tag has been reached. </p>
<p>The rest of the map contains data lines and points. </p>

</div>
</div>
<a class="anchor" id="a00f12f15367b9c97592b0f45fda2fc2f"></a><!-- doxytag: member="ArMapInterface::mapChanged" ref="a00f12f15367b9c97592b0f45fda2fc2f" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classArMapInterface.html#a00f12f15367b9c97592b0f45fda2fc2f">ArMapInterface::mapChanged</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function that will call the map changed CBs if needed. </p>
<p>Users of <a class="el" href="classAria.html" title="Contains global initialization, deinitialization and other global functions.">Aria</a> maps should invoke this method after making any changes to the map. It causes the installed map changed handlers to be invoked.</p>
<p>This method is not thread-safe. It should be surrounded by calls to <a class="el" href="classArMapInterface.html#a2e72e85ff0680d98570b096cf24938ba" title="Lock the map instance.">lock()</a> and <a class="el" href="classArMapInterface.html#a0f53472e8700abcc05a85b9f7a7d6820" title="Unlock the map instance.">unlock()</a>. For example:</p>
<p><code> std::list&lt;ArMapObject*&gt; newMapObjects; // Add some objects... myMap-&gt;<a class="el" href="classArMapInterface.html#a2e72e85ff0680d98570b096cf24938ba" title="Lock the map instance.">lock()</a>; myMap-&gt;setMapObjects(&amp;newMapObjects); myMap-&gt;<a class="el" href="classArMapInterface.html#a00f12f15367b9c97592b0f45fda2fc2f" title="Function that will call the map changed CBs if needed.">mapChanged()</a>; myMap-&gt;<a class="el" href="classArMapInterface.html#a0f53472e8700abcc05a85b9f7a7d6820" title="Unlock the map instance.">unlock()</a>; </code></p>
<p>Note that this method is automatically invoked under some circumstances (such as when the map file is re-read following a change to the robot configuration). Also note that this method will not invoke any callbacks if the map has not been modified via an explicit call to a set method.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classArMapInterface.html#a4473ac4e92936dab506739e7a20b9810" title="Adds a callback that is invoked when the map has been changed.">addMapChangedCB</a> </dd>
<dd>
<a class="el" href="classArMapInterface.html#a68292e93e05b174ee8f35ee5cd11403b" title="Adds a callback called before the map changed callbacks are called.">addPreMapChangedCB</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7a5270bda8f803df83079940ac6e15e5"></a><!-- doxytag: member="ArMapInterface::parseLine" ref="a7a5270bda8f803df83079940ac6e15e5" args="(char *line)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classArMapInterface.html#a7a5270bda8f803df83079940ac6e15e5">ArMapInterface::parseLine</a> </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Public for ArQMapProducer. </p>
<p>Parses a map line </p>

</div>
</div>
<a class="anchor" id="a9ec33c9ef77c8d6fcd6f68b33d0385d9"></a><!-- doxytag: member="ArMapInterface::readFile" ref="a9ec33c9ef77c8d6fcd6f68b33d0385d9" args="(const char *fileName, char *errorBuffer=NULL, size_t errorBufferLen=0, unsigned char *md5DigestBuffer=NULL, size_t md5DigestBufferLen=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classArMapInterface.html#a9ec33c9ef77c8d6fcd6f68b33d0385d9">ArMapInterface::readFile</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>errorBuffer</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>errorBufferLen</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>md5DigestBuffer</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>md5DigestBufferLen</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads the map from the specified file. </p>
<p>If the file is successfully read into the map, then this method calls <a class="el" href="classArMapInterface.html#a00f12f15367b9c97592b0f45fda2fc2f" title="Function that will call the map changed CBs if needed.">mapChanged()</a> afterwards to invoke the installed callbacks.</p>
<p>This method automatically calls <a class="el" href="classArMapInterface.html#a2e72e85ff0680d98570b096cf24938ba" title="Lock the map instance.">lock()</a> and <a class="el" href="classArMapInterface.html#a0f53472e8700abcc05a85b9f7a7d6820" title="Unlock the map instance.">unlock()</a> during operation. Do not call this method if the map is already locked.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>the name of the file to read; Unless an absolute path to a file is given (starting with "/" or "\" or, on Windows, a drive letter root such as "C:\", "D:\", etc.), it is combined with this map's base directory (see <a class="el" href="classArMapInterface.html#a6a75aadc1642ea9f8f6004c09fa94306" title="Gets the base directory.">getBaseDirectory()</a>) to form the complete file path name; must be non-NULL </td></tr>
    <tr><td class="paramname">errorBuffer</td><td>a pointer to a char buffer in which specific read errors can be recorded; if NULL, then the return value is the only success indication </td></tr>
    <tr><td class="paramname">errorBufferLen</td><td>the size_t of the error buffer </td></tr>
    <tr><td class="paramname">md5DigestBuffer</td><td>an optional pointer to a buffer in which to store the calculated checksum of the map; if NULL, then the checksum is not output </td></tr>
    <tr><td class="paramname">md5DigestBufferLen</td><td>the size_t of the checksum buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bool true if the file was successfully read and the map was populated; false if an error occurred </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classArMD5Calculator.html" title="Calculates the MD5 checksum when reading or writing a text file using ArFunctors.">ArMD5Calculator</a> </dd></dl>

<p>Implemented in <a class="el" href="classArMap.html#a41309477c89bc6ee5a8c90c46cc3ab5b">ArMap</a>.</p>

</div>
</div>
<a class="anchor" id="a412f9906797ed2e34e6d4589033e3d80"></a><!-- doxytag: member="ArMapInterface::refresh" ref="a412f9906797ed2e34e6d4589033e3d80" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classArMapInterface.html#a412f9906797ed2e34e6d4589033e3d80">ArMapInterface::refresh</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether the map file needs to be re-read. </p>
<p>This method is primarily applicable to the active <a class="el" href="classAria.html" title="Contains global initialization, deinitialization and other global functions.">Aria</a> map that is associated with the robot configuration. It checks to see if the map file has been modified since it was read, and re-reads it if necessary. The method may do nothing for "simpler" maps. </p>

</div>
</div>
<a class="anchor" id="a65da492e1379f9a9d226b552a2be65d3"></a><!-- doxytag: member="ArMapInterface::remMapChangedCB" ref="a65da492e1379f9a9d226b552a2be65d3" args="(ArFunctor *functor)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classArMapInterface.html#a65da492e1379f9a9d226b552a2be65d3">ArMapInterface::remMapChangedCB</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor.html">ArFunctor</a> *&#160;</td>
          <td class="paramname"><em>functor</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes a callback called when the map has been changed. </p>
<p>This method is not thread-safe.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>a pointer to the <a class="el" href="classArFunctor.html" title="An object which allows storing a generalized reference to a method with an object instance to call la...">ArFunctor</a> to be removed; must be non-NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a80f3ea46ca3969d4eaf6253b39c84f5c"></a><!-- doxytag: member="ArMapInterface::remPostWriteFileCB" ref="a80f3ea46ca3969d4eaf6253b39c84f5c" args="(ArFunctor *functor)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classArMapInterface.html#a80f3ea46ca3969d4eaf6253b39c84f5c">ArMapInterface::remPostWriteFileCB</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor.html">ArFunctor</a> *&#160;</td>
          <td class="paramname"><em>functor</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes the given callback from the list of post-write callbacks. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>the <a class="el" href="classArFunctor.html" title="An object which allows storing a generalized reference to a method with an object instance to call la...">ArFunctor</a> * callback to be removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0563d1953c0795a0ee85ebb2a7c9b13c"></a><!-- doxytag: member="ArMapInterface::remPreMapChangedCB" ref="a0563d1953c0795a0ee85ebb2a7c9b13c" args="(ArFunctor *functor)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classArMapInterface.html#a0563d1953c0795a0ee85ebb2a7c9b13c">ArMapInterface::remPreMapChangedCB</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor.html">ArFunctor</a> *&#160;</td>
          <td class="paramname"><em>functor</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes the specified "pre-map-changed callback". </p>
<p>This method is not thread-safe.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>a pointer to the <a class="el" href="classArFunctor.html" title="An object which allows storing a generalized reference to a method with an object instance to call la...">ArFunctor</a> to be removed; must be non-NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a44fbadba38009509c473ca622a59b8b1"></a><!-- doxytag: member="ArMapInterface::remPreWriteFileCB" ref="a44fbadba38009509c473ca622a59b8b1" args="(ArFunctor *functor)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classArMapInterface.html#a44fbadba38009509c473ca622a59b8b1">ArMapInterface::remPreWriteFileCB</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor.html">ArFunctor</a> *&#160;</td>
          <td class="paramname"><em>functor</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes the given callback from the list of pre-write callbacks. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>the <a class="el" href="classArFunctor.html" title="An object which allows storing a generalized reference to a method with an object instance to call la...">ArFunctor</a> * callback to be removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a20061ab5be4b9b469a7221ca12fdd9be"></a><!-- doxytag: member="ArMapInterface::set" ref="a20061ab5be4b9b469a7221ca12fdd9be" args="(ArMapInterface *other)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classArMapInterface.html#a20061ab5be4b9b469a7221ca12fdd9be">ArMapInterface::set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArMapInterface.html">ArMapInterface</a> *&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets this map to be "equivalent" to the given other map. </p>
<p>Modifies this map so that is effectively a copy of the given map. All info, objects, and data points and lines in the other map are copied and stored in this map. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>a pointer to the <a class="el" href="classArMapInterface.html" title="ArMapInterface defines the methods that are available on all Aria maps.">ArMapInterface</a> to be copied; must not be NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bool true if the map was successfully copied to this one; false if an error occurred </dd></dl>

</div>
</div>
<a class="anchor" id="a60ca7573c074769719b00c3c96ec17c4"></a><!-- doxytag: member="ArMapInterface::setIgnoreCase" ref="a60ca7573c074769719b00c3c96ec17c4" args="(bool ignoreCase=false)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classArMapInterface.html#a60ca7573c074769719b00c3c96ec17c4">ArMapInterface::setIgnoreCase</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreCase</em> = <code>false</code></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets whether we ignore case or not. </p>
<p>This method is primarily applicable to the active <a class="el" href="classAria.html" title="Contains global initialization, deinitialization and other global functions.">Aria</a> map that is associated with the robot configuration. </p>

</div>
</div>
<a class="anchor" id="aa65367c7823f46fdae42d53f201699a5"></a><!-- doxytag: member="ArMapInterface::setIgnoreEmptyFileName" ref="aa65367c7823f46fdae42d53f201699a5" args="(bool ignore)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classArMapInterface.html#aa65367c7823f46fdae42d53f201699a5">ArMapInterface::setIgnoreEmptyFileName</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets whether we ignore empty file names or fail if we encounter one. </p>
<p>This method is primarily applicable to the active <a class="el" href="classAria.html" title="Contains global initialization, deinitialization and other global functions.">Aria</a> map that is associated with the robot configuration. </p>

</div>
</div>
<a class="anchor" id="acac90c5ce18a25ecd6d08ce8116a27aa"></a><!-- doxytag: member="ArMapInterface::setMapObjectParams" ref="acac90c5ce18a25ecd6d08ce8116a27aa" args="(const char *mapObjectName, ArArgumentBuilder *params, ArMapChangeDetails *changeDetails=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classArMapInterface.html#acac90c5ce18a25ecd6d08ce8116a27aa">ArMapInterface::setMapObjectParams</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mapObjectName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArArgumentBuilder.html">ArArgumentBuilder</a> *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArMapChangeDetails.html">ArMapChangeDetails</a> *&#160;</td>
          <td class="paramname"><em>changeDetails</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the optional parameters associated with a map object. </p>
<p>This method sets the parameter values for the specified map object. It should be used only for custom map object types that have a parameter list defined in the MapInfo. (Refer to the <a class="el" href="classArMap.html" title="A map of a two-dimensional space the robot can navigate within, and which can be updated via the Aria...">ArMap</a> MapFileFormat for more information.)</p>
<p>Like <a class="el" href="classArMapInterface.html#a69999157a3713d4ada7d47f6a3087b73" title="Returns the optional parameters associated with a map object, or NULL if none.">findMapObjectParams()</a>, this is basically a convenience method that simplifies access to the data stored in the CairnInfo argument list.</p>
<p>If the given params is non-NULL, then it is copied and stored in the map. (Note that this deletes the pointer previously returned by findMapObjectParams(mapObjectName). Do not store that pointer.) It is entirely the caller's responsibility to ensure that the params arg count and types are correct.</p>
<p>If the given params is NULL, then the parameter information for the map object is cleared. If a mapObjectWithParams is to be deleted, then setMapObjectParams(mapObjectWithParams-&gt;getName(), NULL) must be called first.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mapObjectName</td><td>the unique char * name of the map object whose parameters are to be updated </td></tr>
    <tr><td class="paramname">params</td><td>the ArArgumentBuiler * containing the new parameter values; if NULL, then the parameter information for the map object is deleted </td></tr>
    <tr><td class="paramname">changeDetails</td><td>an optional pointer to the <a class="el" href="classArMapChangeDetails.html" title="Helper class used to track changes to an Aria map.">ArMapChangeDetails</a> in which to accumulate a description of the changes to the map; if NULL, then changes are not tracked </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classArMapChangeDetails.html" title="Helper class used to track changes to an Aria map.">ArMapChangeDetails</a> </dd></dl>

<p>Implemented in <a class="el" href="classArMapSimple.html#a9b3beb8b640bec38f6db16c63fd11232">ArMapSimple</a>.</p>

</div>
</div>
<a class="anchor" id="ac519568cc0d2e3a87d4e7feabf04a7aa"></a><!-- doxytag: member="ArMapInterface::setScanTypes" ref="ac519568cc0d2e3a87d4e7feabf04a7aa" args="(const std::list&lt; std::string &gt; &amp;scanTypeList)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classArMapInterface.html#ac519568cc0d2e3a87d4e7feabf04a7aa">ArMapInterface::setScanTypes</a> </td>
          <td>(</td>
          <td class="paramtype">const std::list&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>scanTypeList</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the scan types that are defined for this map. </p>
<p>This method clears all of the exisiting scans (i.e. point and line data). This method is not thread-safe.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">scanTypeList</td><td>the list of scan type string identifiers to be set; the list must not contain any duplicate entries </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bool true if the scan types were successfully set; false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="adc9644192ab38bd3b8a019d6e910ef42"></a><!-- doxytag: member="ArMapInterface::setSourceFileName" ref="adc9644192ab38bd3b8a019d6e910ef42" args="(const char *sourceName, const char *fileName, bool isInternalCall=false)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classArMapInterface.html#adc9644192ab38bd3b8a019d6e910ef42">ArMapInterface::setSourceFileName</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sourceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isInternalCall</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the name of the source and the file from which the map was loaded. </p>
<p>This method is primarily used to track when a map has been received from the central server or another robot. The source and file name can be retrieved from the map ID. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceName</td><td>the const char * name of the central server or robot from which the map was obtained </td></tr>
    <tr><td class="paramname">fileName</td><td>the const char * name of the map file on the source </td></tr>
    <tr><td class="paramname">isInternalCall</td><td>a bool set to true if this method is being called while the map is locked; if false, then this method will lock the map </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ade2aaba8c0a991964c2a623987a589fe"></a><!-- doxytag: member="ArMapInterface::writeFile" ref="ade2aaba8c0a991964c2a623987a589fe" args="(const char *fileName, bool internalCall=false, unsigned char *md5DigestBuffer=NULL, size_t md5DigestBufferLen=0, time_t fileTimestamp=&#45;1)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classArMapInterface.html#ade2aaba8c0a991964c2a623987a589fe">ArMapInterface::writeFile</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>internalCall</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>md5DigestBuffer</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>md5DigestBufferLen</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>fileTimestamp</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes the map to the specified file. </p>
<p>By default, this method automatically calls <a class="el" href="classArMapInterface.html#a2e72e85ff0680d98570b096cf24938ba" title="Lock the map instance.">lock()</a> and <a class="el" href="classArMapInterface.html#a0f53472e8700abcc05a85b9f7a7d6820" title="Unlock the map instance.">unlock()</a> during its operation. If the map is already locked when the file needs to be written, then set the internalCall parameter to true to override the default locking behavior</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>the const char * name of the file to written; it is combined with the <a class="el" href="classArMapInterface.html#a6a75aadc1642ea9f8f6004c09fa94306" title="Gets the base directory.">getBaseDirectory()</a> to form the complete file path name; must be non-NULL </td></tr>
    <tr><td class="paramname">internalCall</td><td>a bool set to true if writeFile is being called while the map is already locked; set to false to indicate that the map should lock itself during the method </td></tr>
    <tr><td class="paramname">md5DigestBuffer</td><td>an optional pointer to a buffer in which to store the calculated checksum of the map; if NULL, then the checksum is not output </td></tr>
    <tr><td class="paramname">md5DigestBufferLen</td><td>the size_t of the checksum buffer </td></tr>
    <tr><td class="paramname">fileTimestamp</td><td>the time_t to which to set the file write time; in general, this should be left as -1 to indicate that the actual write time is desired; a real time value can be used to synchronize the map across many robots </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bool true if the file was successfully written; false if an error occurred </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classArMD5Calculator.html" title="Calculates the MD5 checksum when reading or writing a text file using ArFunctors.">ArMD5Calculator</a> </dd></dl>

<p>Implemented in <a class="el" href="classArMap.html#a3922ae9a351c1739a24d9247f7db1cc5">ArMap</a>.</p>

</div>
</div>
<a class="anchor" id="abc4e372308bbf06195dea3c0bccc93b8"></a><!-- doxytag: member="ArMapInterface::writeObjectsToFunctor" ref="abc4e372308bbf06195dea3c0bccc93b8" args="(ArFunctor1&lt; const char * &gt; *functor, const char *endOfLineChars, bool isOverrideAsSingleScan=false, const char *maxCategory=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classArMapInterface.html#abc4e372308bbf06195dea3c0bccc93b8">ArMapInterface::writeObjectsToFunctor</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor1.html">ArFunctor1</a>&lt; const char * &gt; *&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>endOfLineChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isOverrideAsSingleScan</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>maxCategory</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes the map header information and objects to a text-based functor. </p>
<p>This method writes all of the map scan headers, the info arguments, and the Cairn map objects to the given functor. It does not write the actual scan point or line segment data (nor the header lines that introduce the data). This method is not thread-safe.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>a pointer to the <a class="el" href="classArFunctor1.html" title="Base class for functors with 1 parameter.">ArFunctor1</a> to which to write the map header as text lines </td></tr>
    <tr><td class="paramname">endOfLineChars</td><td>the const char * string to use as an end-of-line indicator </td></tr>
    <tr><td class="paramname">isOverrideAsSingleScan</td><td>a bool set to true if only a single scan header should be written; this is generally the "summary scan" and is used to maintain backwards compatibility with client applications that do not expect multiple scan types in a single map. </td></tr>
    <tr><td class="paramname">maxCategory</td><td>if given, limit map category </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4721211e839289dc8ab24202e07471cc"></a><!-- doxytag: member="ArMapInterface::writeToFunctor" ref="a4721211e839289dc8ab24202e07471cc" args="(ArFunctor1&lt; const char * &gt; *functor, const char *endOfLineChars)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classArMapInterface.html#a4721211e839289dc8ab24202e07471cc">ArMapInterface::writeToFunctor</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArFunctor1.html">ArFunctor1</a>&lt; const char * &gt; *&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>endOfLineChars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes all of the map to the given text-based functor. </p>
<p>This method is not thread-safe </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>a pointer to the <a class="el" href="classArFunctor1.html" title="Base class for functors with 1 parameter.">ArFunctor1</a> to which to write the map header as text lines </td></tr>
    <tr><td class="paramname">endOfLineChars</td><td>the const char * string to use as an end-of-line indicator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="ArMapInterface_8h.html">ArMapInterface.h</a></li>
<li>ArMapInterface.cpp</li>
</ul>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="classArMapInterface.html">ArMapInterface</a>      </li>

    <li class="footer">Generated on Mon Nov 10 2014 07:58:48 for Aria by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
